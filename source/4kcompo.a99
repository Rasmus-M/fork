*********************************************************************
*
* 4K Compo
* For the TI-99/4A home computer
*
* January 2017
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Constants
*
win_width:
       equ  32
win_height:
       equ  22
center_x:
       equ  >78
center_y:
       equ  >58
start_x:
       equ  >0060
start_y:
       equ  >0060
chr_space:
       equ  >e0
chr_plus:
       equ  >e1
chr_minus:
       equ  >e3
chr_zero:
       equ  >e5
chr_question:
       equ  >f1

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400
grmrd  equ  >9800                      ; GROM read data (GROM base)
grmra  equ  >9802                      ; GROM read address+1
grmwd  equ  >9C00
grmwa  equ  >9C02

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 0        >0000 - >03FF (128 patterns)
nametb equ  >0400                      ; Name table base 0           >0400 - >06FF
                                       ; Pattern table 0 high        >0700 - >07FF (32 patterns)
ptrnt1 equ  >0800                      ; Pattern table base 1        >0800 - >0BFF (128 patterns)
namet1 equ  >0c00                      ; Name table base             >0C00 - >0EFF
                                       ; Pattern table 1 high        >0F00 - >0FFF (32 patterns)
ptrnt2 equ  >1000                      ; Pattern table base 2        >1000 - >13FF (128 patterns)
sprptb equ  >1000                      ; Sprite pattern table base   >1400 - >16FF (24 sprite patterns)
                                       ; Pattern table 2 high        >1700 - >17FF (32 patterns)
ptrnt3 equ  >1800                      ; Pattern table base 3        >1800 - >1BFF (128 patterns)
spratb equ  >1C00                      ; Sprite attribute table base >1C00 - >1C7F
colrtb equ  >1C80                      ; Color table base            >1C80 - >1CFF
sprat1 equ  >1D00                      ; Sprite attribute table base >1D00 - >1D7F
                                       ; Unused                      >1D80 - >1EFF (>180 bytes)
                                       ; Pattern table 3 high        >1F00 - >1FFF (32 patterns)
ptrnt4 equ  >2000                      ; Pattern table base 4        >2000 - >23FF (128 patterns)
                                       ; Unused                      >2400 - >26FF (>300 bytes)
                                       ; Pattern table 4 high        >2700 - >27FF (32 patterns)
ptrnt5 equ  >2800                      ; Pattern table base 5        >2800 - >2BFF (128 patterns)
                                       ; Unused                      >2C00 - >2EFF (>300 bytes)
                                       ; Pattern table 5 high        >2F00 - >2FFF (32 patterns)
ptrnt6 equ  >3000                      ; Pattern table base 6        >3000 - >33FF (128 patterns)
                                       ; Unused                      >3400 - >36FF (>300 bytes)
                                       ; Pattern table 6 high        >3700 - >37FF (32 patterns)
ptrnt7 equ  >3800                      ; Pattern table base 7        >3800 - >3BFF (128 patterns)
                                       ; Unused                      >3C00 - >3EFF (>300 bytes)
                                       ; Pattern table 7 high        >3F00 - >3FFF (32 patterns)

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables
*
* PAD variables
*
frame_no:
       equ  padvar
rand_no:
       equ  frame_no+2
x:                                     ; smmmmmmmtttpppff
       equ  rand_no+2                  ; s=sign, m=metatile, t=tile, p=pixel, f=fraction
y:                                     ; smmmmmmmtttpppff
       equ  x+2
vx:                                    ; ppppppppssssssss
       equ  y+2
vy:                                    ; ppppppppssssssss
       equ  vx+2
ax:                                    ; ppppppppssssssss
       equ  vy+2
ay:                                    ; ppppppppssssssss
       equ  ax+2
player_sprite:
       equ  ay+2
joystick_input:
       equ  player_sprite+2
double_buffer_flag:
       equ  joystick_input+2
double_buffer_address:
       equ double_buffer_flag+2
goto_x:
       equ  double_buffer_address+2
goto_y:
       equ  goto_x+2
time_left:
       equ  goto_y+2
buffer:
       equ  time_left+2                ; 32 bytes buffer
copy_loop:
       equ  buffer+32
pad_max:
       equ  copy_loop+24

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r13,vdpwd                  ; Do not change
       bl   @init
       bl   @init_game
main_loop:
       bl   @vsync
       bl   @set_vdp_tables
       bl   @user_input
       bl   @move
       bl   @update_sprites
       bl   @calculate_nt_address
       bl   @update_name_table
       bl   @check_position
       bl   @display_position
       bl   @display_time_left
       inc  @frame_no
       jmp  main_loop
*// main

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,r12
       b    *r11
*// vsync

*********************************************************************************
*
* Set VDP tables
*
set_vdp_tables:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Set pattern table according to horizontal scroll offset
       mov  @x,r0
       sra  r0,2                       ; Shift out sub-pixels
       andi r0,>0007                   ; Isolate pixels
       ori  r0,>0400
       bl   @vwtr
*      Flip name table
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0201
       bl   @vwtr
*      Set sprite attribute table
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0538
       bl   @vwtr
*      Flip double buffer flag
       inv  @double_buffer_flag
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// set_vdp_tables

*********************************************************************************
*
* User input
*
user_input:
       clr  @ax
       clr  @ay
*      Read joystick #1 using CRU
       li   r12,>0024                  ; CRU address of the column decoder
       li   r0,>0600                   ; Column 6, i.e joystick #1
       ldcr r0,3                       ; Select it
       li   r12,>0006                  ; Base CRU address for joystick 1
       stcr r1,8
       inv  r1
       andi r1,>ff00
       mov  r1,r0
       swpb r1
       mov  r1,@joystick_input
*      Up
       sla  r0,4
       jnc  user_input_1
       li   r1,->0020
       mov  r1,@ay
user_input_1:
*      Down
       sla  r0,1
       jnc  user_input_2
       li   r1,>0020
       mov  r1,@ay
user_input_2:
*      Right
       sla  r0,1
       jnc  user_input_3
       li   r1,>0020
       mov  r1,@ax
user_input_3:
*      Left
       sla  r0,1
       jnc  user_input_4
       li   r1,->0020
       mov  r1,@ax
user_input_4:
*      Fire
       sla  r0,1
       jnc  user_input_5
       ;      TODO
user_input_5:
       b    *r11
*// user_input

*********************************************************************************
*
* Move player
*
move:
*      X
       mov  @vx,r0                     ; Velocity
       mov  @ax,r1
       jeq  move_1
*      Accelerate
       a    r1,r0
       jmp  move_3
*      Decelerate
move_1:
       mov  r0,r1                      ; Velocity
       jlt  move_2
       ci   r1,>00c0
       jgt  move_2
       clr  r0                         ; Stop
       jmp  move_3
move_2:
       sra  r1,6                       ; Divide velocity by 16
       s    r1,r0                      ; Subtract from velocity
move_3:
       mov  r0,@vx                     ; Save velocity
       sra  r0,8                       ; Shift to LSB
       a    r0,@x                      ; Add to position
*      Y
       mov  @vy,r0                     ; Velocity
       mov  @ay,r1
       jeq  move_4
*      Accelerate
       a    r1,r0
       jmp  move_6
*      Decelerate
move_4:
       mov  r0,r1                      ; Velocity
       jlt  move_5
       ci   r1,>00c0
       jgt  move_5
       clr  r0                         ; Stop
       jmp  move_6
move_5:
       sra  r1,6                       ; Divide velocity by 16
       s    r1,r0                      ; Subtract from velocity
move_6:
       mov  r0,@vy                     ; Save velocity
       sra  r0,8                       ; Shift to LSB
       a    r0,@y                      ; Add to position
*      Return
       b    *r11
*// move

*********************************************************************************
*
* Update sprites
*
update_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
*      VDP address
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0038
       sla  r0,7
*      Player
       mov  @joystick_input,r1
       jne  update_sprites_1
       mov  @player_sprite,r1
       jmp  update_sprites_2
update_sprites_1:
       srl  r1,1
       movb @dir_sprite_table(r1),r2
       mov  @player_sprite,r1
       cb   r2,r1
       jeq  update_sprites_2
       ai   r1,->0040
       andi r1,>07ff
update_sprites_2:
       mov  r1,@player_sprite
       sla  r1,2
       ai   r1,>a000
       ai   r0,16+2
       bl   @vsbw
       movb @player_init+3,*r13
*      Goto sprite
       mov  @y,r4
       andi r4,>fffc
       neg  r4
       a    @goto_y,r4
       sra  r4,2
       ai   r4,center_y+>18
       ci   r4,191
       jgt  update_sprites_4
       ci   r4,-15
       jlt  update_sprites_4
       mov  @x,r5
       andi r5,>fffc
       neg  r5
       a    @goto_x,r5
       sra  r5,2
       ai   r5,center_x+>18
       ci   r5,255
       jgt  update_sprites_4
       ci   r5,-31
       jlt  update_sprites_4
       li   r0,>c00a
       ci   r5,0
       jgt  update_sprites_3
       ai   r5,32
       ori  r0,>0080
update_sprites_3:
       dec  r4
       movb @r4lb,*r13
       movb @r5lb,*r13
       movb r0,*r13
       movb @r0lb,*r13
update_sprites_4:
;*      Tiles
;*      Start x
;       mov  @x,r4
;       sla  r4,5
;       sra  r4,7                       ; -256 - 255
;       neg  r4
;       ai   r4,center_x->40+>18
;*      Start y
;       mov  @y,r5
;       sla  r5,5
;       sra  r5,7                       ; -256 - 255
;       neg  r5
;       ai   r5,center_y->40+>18
;*      Pattern and color
;       li   r6,>8000
;*      Row loop
;       clr  r3
;update_sprites_4:
;*      Column loop
;       clr  r2
;update_sprites_5:
;       mov  r4,r0
;       ci   r0,>ff
;       jgt  update_sprites_6
;       li   r7,>0400
;       ci   r0,>20
;       jgt  update_sprites_2
;       ai   r0,>20
;       jlt  update_sprites_6
;       ori  r7,>8000
;update_sprites_2:
;       movb @r5lb,*r13
;       movb @r0lb,*r13
;       movb r6,*r13
;       movb r7,*r13
;*      Next column
;update_sprites_6:
;       ai   r4,>40
;       inc  r2
;       ci   r2,3
;       jne  update_sprites_5
;*      Next row
;       ai   r4,->c0
;       ai   r5,>40
;       inc  r3
;       ci   r3,3
;       jne  update_sprites_4
*      End marker
       movb @player_init+4,*r13
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
dir_sprite_table:
       byte >00                        ; 0 None
       byte >04                        ; 1 Left
       byte >00                        ; 2 Right
       byte >00                        ; 3 Left + right (N/A)
       byte >02                        ; 4 Up
       byte >07                        ; 5 Up + left
       byte >05                        ; 6 Up + right
       byte >05                        ; 7 Up + left + right (N/A)
       byte >06                        ; 8 Down
       byte >01                        ; 9 Down + left
       byte >03                        ; A Down + right
       byte >03                        ; B Down + left + right (N/A)
       byte >02                        ; C Up + down (N/A)
       byte >07                        ; D Up + down + left (N/A)
       byte >05                        ; E Up + down + right (N/A)
       byte >05                        ; F Up + down + left + right (N/A)
*// update_sprites

*********************************************************************************
*
* Update name table
*
update_name_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       bl   @vwad
       li   r0,8
*      Tile offsets
       mov  @x,r4
       sra  r4,5                       ; Shift out pixels and sub-pixels
       andi r4,7                       ; Column offset
       mov  @y,r5
       mov  r5,r6
       sra r5,5                        ; Row offset
       andi r6,>001c                   ; Pixel row offset * 4
*      Row loop
       clr  r3
update_name_table_1:
       mov  r3,r1                      ; Row
       a    r5,r1                      ; Add row offset
       andi r1,7                       ; Mod 8
       sla  r1,1                       ; To word offset
       mov  @map_row_index(r1),r1      ; Map row number
       a    r6,r1                      ; Add pixel row offset
       sla  r1,4                       ; Multiply by 16
       ai   r1,map_rows
       a    r4,r1                      ; Add column offset
*      Column loop
       li   r2,win_width/8
       bl   @copy_loop
*      Next row
       inc  r3
       ci   r3,win_height
       jlt  update_name_table_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*      Copy loop
copy_loop_1:
       movb *r1+,*r13                  ; Write to VDP
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       s    r0,r1
       dec  r2
       jne  copy_loop_1
       b    *r11
copy_loop_2
*// update_name_table

*********************************************************************************
*
* Check position
*
check_position:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @x,r0
       s    @goto_x,r0
       abs  r0
       ci   r0,>0040
       jgt  check_position_1
       mov  @y,r0
       s    @goto_y,r0
       abs  r0
       ci   r0,>0040
       jgt  check_position_1
*      Collision
       bl   @update_goto_position
*      Return
check_position_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// check_position

*********************************************************************************
*
* Display position
*
display_position:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       ai   r0,22*32+2
       bl   @vwad
       mov  @x,r1
       bl   @display_byte
       mov  @double_buffer_address,r0
       ai   r0,22*32+9
       bl   @vwad
       mov  @y,r1
       bl   @display_byte
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// display_position

*********************************************************************************
*
* Display goto position
*
display_goto_position:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       ai   r0,22*32+21
       bl   @vwad
       mov  @goto_x,r1
       bl   @display_byte
       mov  @double_buffer_address,r0
       ai   r0,22*32+28
       bl   @vwad
       mov  @goto_y,r1
       bl   @display_byte
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// display_goto_position

*********************************************************************************
*
* Display time left
*
display_time_left:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @time_left,r0
       jeq  display_time_left_1
       ai   r0,-4
       mov  r0,@time_left
       andi r0,>00ff
       jne  display_time_left_1
       li   r0,23*32+5+nametb
       bl   @vwad
       mov  @time_left,r1
       bl   @display_unsigned_byte
       li   r0,23*32+5+namet1
       bl   @vwad
       mov  @time_left,r1
       bl   @display_unsigned_byte
*      Return
display_time_left_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// display_time_left

*********************************************************************************
*
* update goto positions
*
update_goto_position:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @rand
       andi r0,>ff00
;      li   r0,>0100
       mov  r0,@goto_x
       bl   @rand
       andi r0,>ff00
;      li   r0,>0100
       mov  r0,@goto_y
       li   r0,nametb
       mov  r0,@double_buffer_address
       bl   @display_goto_position
       li   r0,namet1
       mov  r0,@double_buffer_address
       bl   @display_goto_position
       li   r0,>6400
       mov  r0,@time_left
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// update_goto_position

*********************************************************************************
*
* Calculate address of current name table double buffer
*
calculate_nt_address:
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0001
       sla  r0,10
       mov  r0,@double_buffer_address
       b    *r11
*// calculate_nt_address

*********************************************************************************
*
* Initialize game
*
init_game:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r0,start_x
       mov  r0,@x
       li   r0,start_y
       mov  r0,@y
       clr  @vx
       clr  @vy
       clr  @double_buffer_flag
       clr  @frame_no
       clr  @player_sprite
       bl   @update_goto_position
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// init_game

*********************************************************************************
*
* One time initializations
*
init:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r0,copy_loop_1
       li   r1,copy_loop
       li   r2,copy_loop_2-copy_loop_1
       bl   @copy_memory
       bl   @f18a_init
       bl   @gmode
       bl   @init_patterns
       bl   @init_gfx
       li   r0,22*32
       li   r1,text_line_1
       bl   @display_text
       li   r0,23*32
       li   r1,text_line_2
       bl   @display_text
       bl   @init_map                  ; Overwrites graphics
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// init

*********************************************************************************
*
* Initialize map
*
init_map:
       li   r0,map_rows
       li   r1,map_rows+64
       li   r2,7*64
       li   r3,>1000
init_map_1:
       movb *r0+,r4
       ab   r3,r4
       movb r4,*r1+
       dec  r2
       jne  init_map_1
*      Return
       b    *r11
*// init_map

*********************************************************************************
*
* Scroll patterns and upload to VDP
*
init_patterns:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @hscroll
       bl   @vscroll
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// init_patterns

*********************************************************************************
*
* Scroll patterns horizontally and upload to VDP
*
h_patterns:
       equ  12
*
hscroll:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r6,hchars                 ; Pointer to from/to pattern numbers
*      Pattern loop
       clr  r3                         ; Pattern counter
hscroll_1:
*      Scroll offset loop
       clr  r4                         ; Horizontal scroll offset (0-7)
hscroll_2:
       mov  *r6,r7                     ; Get from and to pattern numbers
       mov  r7,r8
       andi r7,>ff00
       srl  r7,5
       ai   r7,pat0                    ; Address of from pattern
       andi r8,>00ff
       sla  r8,3
       ai   r8,pat0                    ; Address of to pattern
*      Write address
       mov  r3,r0                      ; Pattern number
       sla  r0,3                       ; Multiply by 8
       mov  r4,r1                      ; Scroll offset
       sla  r1,11                      ; Multiply by >800
       ai   r1,ptrntb+>400             ; Add pattern table base plus offset
       a    r1,r0
       bl   @vwad                      ; Setup write address
*      Row loop
       li   r9,8                       ; Row counter
hscroll_3:
       movb *r7+,r1                    ; Get from byte
       movb *r8+,@r1lb                 ; Get to byte
       mov  r4,r0                      ; Get scroll offset
       jeq  hscroll_4                  ; Skip shift if zero
       sla  r1,0
hscroll_4:
       movb r1,*r13                    ; Send to VDP
*      Next row
       dec  r9
       jne  hscroll_3
*      Next scroll offset
       inc  r4
       ci   r4,8
       jlt  hscroll_2
*      Next pattern
       inct r6
       inc  r3
       ci   r3,h_patterns                      ;
       jlt  hscroll_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// hscroll

*********************************************************************************
*
* Scroll horizontal patterns vertically and upload to VDP
*
v_patterns:
       equ  16
*
vscroll:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r6,vchars                  ; Pointer to from/to pattern numbers
*      Pattern loop
       clr  r3                         ; Pattern counter
vscroll_1:
       mov  *r6+,r7                     ; Get from and to pattern numbers
       swpb r7
       mov  r7,r8
       andi r7,>ff00
       srl  r7,5
       andi r8,>00ff
       sla  r8,3
*      Horizontal loop
       clr  r4                         ; Horizontal offset (0-7)
vscroll_2:
*      Read from pattern
       mov  r4,r0
       sla  r0,11
       ai   r0,ptrntb+>400
       a    r7,r0
       li   r1,from_pattern
       li   r2,8
       bl   @vmbr
*      Read to pattern
       mov  r4,r0
       sla  r0,11
       ai   r0,ptrntb+>400
       a    r8,r0
       li   r1,to_pattern
       li   r2,8
       bl   @vmbr
*      Vertical loop
       clr  r5                         ; Vertical offset (0-7)
vscroll_3:
*      Write address
       mov  r3,r0                      ; Pattern number
       sla  r0,3                       ; Multiply by 8
       mov  r4,r1                      ; Horizontal scroll offset
       sla  r1,11                      ; Multiply by >800
       ai   r1,ptrntb                  ; Add pattern table base
       a    r1,r0                      ; Add to address
       mov  r5,r1                      ; Vertical scroll offset
       sla  r1,7                       ; Multiply by >80
       a    r1,r0                      ; Add to address
       bl   @vwad                      ; Setup write address
*      Row loop
       li   r9,8                       ; Row counter
       li   r1,from_pattern            ; Address of from/to pattern buffer
       a    r5,r1                      ; Add vertical scroll offset
vscroll_4:
       movb *r1+,*r13
       dec  r9
       jne  vscroll_4
*      Next vertical scroll offset
       inc  r5
       ci   r5,8
       jlt  vscroll_3
*      Next horizontal scroll offset
       inc  r4
       ci   r4,8
       jlt  vscroll_2
*      Next pattern
       inc  r3
       ci   r3,v_patterns                      ;
       jlt  vscroll_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
from_pattern:
       equ  buffer
to_pattern:
       equ  buffer+8
*// vscroll

*********************************************************************************
*
* Init graphics
*
init_gfx:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Name tables
       li   r1,chr_space*256
       li   r0,nametb
       li   r2,>300
       bl   @vsmw
       li   r0,namet1
       li   r2,>300
       bl   @vsmw
*      Colors
       li   r0,colrtb
       li   r1,>f100
       li   r2,16
       bl   @vsmw
       li   r0,colrtb+16
       li   r1,>8100
       li   r2,16
       bl   @vsmw
*      Sprite patterns
       li   r0,sprptb+>400
       li   r1,SPR8
       li   r2,18*32
       bl   @vmbw
*      Sprite attributes
       li   r0,spratb
       li   r4,2
init_gfx_0:
       bl   @vwad
       li   r3,4
init_gfx_1:
       li   r1,mask_init
       li   r2,4
init_gfx_2:
       movb *r1+,*r13
       dec  r2
       jne  init_gfx_2
       dec  r3
       jne  init_gfx_1
       li   r2,5
init_gfx_3:
       movb *r1+,*r13
       dec  r2
       jne  init_gfx_3
*      Next table
       ai   r0,>100
       dec  r4
       jne  init_gfx_0
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
mask_init:
       byte >af,>00,>00,>00
player_init:
       byte center_y,center_x,>a0,>08
end_marker:
       byte >d0,>00
*// init_gfx

*********************************************************************************
*
* Set graphics mode
*
gmode:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  r0
       li   r1,vregs
       li   r2,8
gmode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  gmode_1
*      Clear VDP RAM
       clr  r0
       clr  r1
       li   r2,>4000
       bl   @vsmw
*      Read character set from GROM
       li   r0,ptrntb+>700
       li   r3,8
gmode_2:
       bl   @vwad
       li   r4,charset
       li   r5,32
gmode_3:
       clr  r1
       movb *r4+,@r1lb
       ai   r1,-32
       mov  r1,r6
       sla  r1,3
       s    r6,r1
       ai   r1,1716
       movb r1,@grmwa
       movb @r1lb,@grmwa
       clr  *r13                       ; Top line
       li   r2,7
gmode_4:
       movb @grmrd,*r13
       dec  r2
       jne  gmode_4
       dec  r5
       jne  gmode_3
       ai   r0,>800
       dec  r3
       jne  gmode_2
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*      VDP registers
vregs:
       byte >00                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte nametb/>400                ; Name table
       byte colrtb/>40                 ; Color table
       byte ptrntb/>800                ; Pattern table
       byte spratb/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// gmode

********************************************************************************
*
* F18A initalize
*
* If an F18A is present we need to set the number of sprites per line to four.
*
f18a_init:
       mov  r11,*r10+                  ; Push return address onto the stack
*      F18A  Unlock
       li   r0,>391c                   ; VR1/57, value 00011100
       bl   @vwtr                      ; Write once
       bl   @vwtr                      ; Write twice, unlock
*      Disable interrupts
       li   r0,>01c2
       bl   @vwtr
*      Check the version status reg
       mov  @vdpsta,r0                  ; Clear status
       li   r0,>0f01                    ; Set to read reg 1, Identity
       bl   @vwtr
       movb @vdpsta,r0
       andi r0,>f000
       ci   r0,>e000
       jne  f18a_init_1
*      Set four sprites per line
       li   r0, >1e04
       bl   @vwtr
f18a_init_1:
       li   r0, >0f00                   ; Set to read reg 0
       bl   @vwtr
*      Enable interrupts
       li   r0, >01e2                   ; Set Reg 1 to a sane value
       bl   @vwtr                      ; Write
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// f18a_init

*********************************************************************
*
* VDP Write To Register
*
* r0 MSB: VDP register to write to
* r0 LSB: Value to write
*
vwtr:
       movb @r0lb,@vdpwa               ; Send low byte (value) to write to VDP register
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* r0: Write address in VDP RAM
*
* r0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* r0: Write address in VDP RAM
* r1: MSB of R1 sent to VDP RAM
*
* r0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r13                    ; Write byte to VDP RAM
       b    *r11
*// vsbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* r0: Write address in VDP RAM
* r1: MSB of R1 sent to VDP RAM
* r2: Number of bytes to send
*
* r0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsmw:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*r13                    ; Write byte to VDP RAM
       dec  r2
       jne  vsmw_1
       b    *r11
*// vsbw

*********************************************************************
*
* VDP Multiply Byte Write
*
* r0: Destination address
* r1: Source address
* r2: Number of bytes to copy
*
vmbw:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,*r13                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       b    *r11
*// vdpcp

***************************************************************************
*
* VDP Multiple Byte Read
*
* r0: Starting read address in VDP RAM
* r1: Starting write address in CPU RAM
* r2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Copy memory
*
* r0: Source address
* r1: Destination address
* r2: Length
*
copy_memory:
       mov  *r0+,*r1+
       dect r2
       jne  copy_memory
       b    *r11
*// copy_memory

*********************************************************************
*
* Display signed byte as decimal
*
* r1: Byte to display in MSB
* VDP address must already be set up.
*
display_unsigned_byte:
       sra  r1,8
       jmp  display_byte_3
display_byte:
       sra  r1,8
       jgt  display_byte_1
       jlt  display_byte_2
       movb @space,*r13
       jmp  display_byte_3
display_byte_1:
       movb @plus,*r13
       jmp  display_byte_3
display_byte_2:
       movb @minus,*r13
       neg  r1
display_byte_3:
       li   r2,2
       li   r3,divisors
display_byte_4:
       clr  r0
       div  *r3+,r0
       ai   r0,chr_zero
       movb @r0lb,*r13
       dec  r2
       jne  display_byte_4
       ai   r1,chr_zero
       movb @r1lb,*r13
       b    *r11
plus:
       byte chr_plus
minus:
       byte chr_minus
space:
       byte chr_space
divisors:
       data 100,10
*// display_byte

*********************************************************************************
*
* Display text to both name table buffers (slow)
*
* r0: VDP offset
* r1: Points to zero terminated ascii text
*
display_text:
       mov  r11,*r10+                  ; Push return address onto the stack
       ai   r0,nametb
       bl   @vwad
       li   r2,buffer
display_text_0:
       movb *r1+,r4
       jeq  display_text_4
       li   r5,charset
       clr  r6
display_text_1:
       cb   r4,*r5+
       jeq  display_text_2
       inc  r6
       ci   r6,32
       jlt  display_text_1
       li   r6,chr_question
       jmp  display_text_3
display_text_2:
       ai   r6,>00e0
display_text_3:
       swpb r6
       movb r6,*r13
       movb r6,*r2+
       jmp  display_text_0
*      2nd name table buffer
display_text_4:
       ai   r0,namet1-nametb
       li   r1,buffer
       ai   r2,-buffer
       bl   @vmbw
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// display_text

*********************************************************************
*
* Random number generator
*
* The random number is returned in r0.
* Modifies r1
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r0,31873                   ; Add a prime number
       src  r0,7                       ; Shift to break odd/even pattern
       mov  r0,@rand_no
       b    *r11
*// rand

*********************************************************************

text_line_1:
       text "X= 000 Y= 000 GOTO X= 000 Y= 000"
       byte 0
text_line_2:
       text "TIME:100 SCORE:00000 LVS:3 LVL:1"
       byte 0
      even

       copy "graphics.a99"
       copy "charset.a99"

*********************************************************************

last_word:
       data -1

       end main
