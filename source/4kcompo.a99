*********************************************************************
*
* Fork - 4K Compo
* For the TI-99/4A home computer
*
* January 2017
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Constants
*
win_width:
       equ  32
win_height:
       equ  22
center_x:
       equ  >78
center_y:
       equ  >58
start_x:
       equ  >0060
start_y:
       equ  >0060
chr_space:
       equ  >e0
chr_plus:
       equ  >e1
chr_minus:
       equ  >e2
chr_zero:
       equ  >e4
chr_question:
       equ  >f0
n_sprite_patterns:
       equ   20
n_tile_sprites:
       equ  8
n_enemy_sprites:
       equ  8
n_bullet_sprites:
       equ  3
n_sprites:
       equ  n_tile_sprites+n_enemy_sprites+n_bullet_sprites
**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400
grmrd  equ  >9800                      ; GROM read data (GROM base)
grmra  equ  >9802                      ; GROM read address+1
grmwd  equ  >9C00
grmwa  equ  >9C02

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base 0        >0000 - >03FF (128 patterns)
nametb equ  >0400                      ; Name table base 0           >0400 - >06FF
                                       ; Pattern table 0 high        >0700 - >07FF (32 patterns)
ptrnt1 equ  >0800                      ; Pattern table base 1        >0800 - >0BFF (128 patterns)
namet1 equ  >0c00                      ; Name table base             >0C00 - >0EFF
                                       ; Pattern table 1 high        >0F00 - >0FFF (32 patterns)
ptrnt2 equ  >1000                      ; Pattern table base 2        >1000 - >13FF (128 patterns)
sprptb equ  >1000                      ; Sprite pattern table base   >1400 - >16FF (24 sprite patterns)
                                       ; Pattern table 2 high        >1700 - >17FF (32 patterns)
ptrnt3 equ  >1800                      ; Pattern table base 3        >1800 - >1BFF (128 patterns)
spratb equ  >1C00                      ; Sprite attribute table base >1C00 - >1C7F
colrtb equ  >1C80                      ; Color table base            >1C80 - >1CFF
sprat1 equ  >1D00                      ; Sprite attribute table base >1D00 - >1D7F
                                       ; Unused                      >1D80 - >1EFF (>180 bytes)
                                       ; Pattern table 3 high        >1F00 - >1FFF (32 patterns)
ptrnt4 equ  >2000                      ; Pattern table base 4        >2000 - >23FF (128 patterns)
                                       ; Unused                      >2400 - >26FF (>300 bytes)
                                       ; Pattern table 4 high        >2700 - >27FF (32 patterns)
ptrnt5 equ  >2800                      ; Pattern table base 5        >2800 - >2BFF (128 patterns)
                                       ; Unused                      >2C00 - >2EFF (>300 bytes)
                                       ; Pattern table 5 high        >2F00 - >2FFF (32 patterns)
ptrnt6 equ  >3000                      ; Pattern table base 6        >3000 - >33FF (128 patterns)
                                       ; Unused                      >3400 - >36FF (>300 bytes)
                                       ; Pattern table 6 high        >3700 - >37FF (32 patterns)
ptrnt7 equ  >3800                      ; Pattern table base 7        >3800 - >3BFF (128 patterns)
                                       ; Unused                      >3C00 - >3EFF (>300 bytes)
                                       ; Pattern table 7 high        >3F00 - >3FFF (32 patterns)

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
stack  equ  wrksp+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables
*
* PAD variables
*
rand_no:
       equ  padvar
frame_no:
       equ  rand_no+2
coinc:
       equ  frame_no+2
double_buffer_flag:
       equ  coinc+2
double_buffer_address:
       equ double_buffer_flag+2
joystick_input:
       equ  double_buffer_address+2
fire:
       equ  joystick_input+2
player_sprite:
       equ  fire+2
player_pattern:                        ; Alias for player_sprite
       equ  player_sprite
player_x:                              ; smmmmmmmtttpppff s=sign, m=metatile, t=tile, p=pixel, f=fraction
       equ  player_pattern+2
player_y:                              ; smmmmmmmtttpppff
       equ  player_x+2
player_vx:                             ; ppppppppssssssss
       equ  player_y+2
player_vy:                             ; ppppppppssssssss
       equ  player_vx+2
player_ax:                             ; ppppppppssssssss
       equ  player_vy+2
player_ay:                             ; ppppppppssssssss
       equ  player_ax+2
player_count:                          ; Counter
       equ  player_ay+2
player_dx:                             ; Direction x
       equ  player_count+2
player_dy:                             ; Direction y
       equ  player_dx+2
lives:                                 ; Number of lives
       equ  player_dy+2
level:                                 ; Level number
       equ  lives+2
score:                                 ; Score
       equ  level+2
disp_score:                            ; Currently displayed score
       equ  score+2
time_left:                             ; Time left to finish level
       equ  disp_score+2
snd_address_0:                         ; Sound address channel 0
       equ  time_left+2
snd_address_1:                         ; Sound address channel 1
       equ  snd_address_0+2
snd_counter_0:                         ; Sound counter 0
       equ  snd_address_1+2
snd_counter_1:                         ; Sound counter 1
       equ  snd_counter_0+2
buffer:                                ; 32 bytes buffer
       equ  snd_counter_1+2
copy_loop:                             ; Code in PAD
       equ  buffer+32
pad_max:                               ; Next availble PAD address
       equ  copy_loop+24
pad_init_start:                        ; Clear from here
       equ  frame_no
pad_init_end:                          ; Clear to here
       equ  snd_counter_1

* Sprite structure
sprite_pattern:                        ; If 0 then not allocated
       equ  0
sprite_color:
       equ  1
sprite_x:                              ; smmmmmmmtttpppff
       equ  2
sprite_y:                              ; smmmmmmmtttpppff
       equ  4
sprite_vx:                             ; ppppppppssssssss
       equ  6
sprite_vy:                             ; ppppppppssssssss
       equ  8
sprite_ax:                             ; ppppppppssssssss
       equ  10
sprite_ay:                             ; ppppppppssssssss
       equ  12
sprite_count:
       equ  14
sprite_size:
       equ  16

player_pat_col:
       equ  >8008
enemy_pat_col:
       equ  >a002
target_pat_col:
       equ  >c00a
ball_pat_col:
       equ  >c405
life_pat_col:
       equ  >c80c
bullet_pat_col:
       equ  >cc0e

********************************************************************************
*
* Main program
*
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       mov  @rndsd,@rand_no            ; Save random number seed
       li   r13,vdpwd                  ; Do not change
       li   r15,main_return
       bl   @init
new_game:
       bl   @init_game
       li   r0,128+9
       li   r1,text_fire_to_start
       bl   @display_text
       bl   @wait_fire
main_loop:
       bl   @vsync
       bl   @main_actions
       mov  @lives,r0
       jeq  game_over
       inc  @frame_no
       jmp  main_loop
game_over:
       li   r0,128+11
       li   r1,text_game_over
       bl   @display_text
       bl   @wait_fire
       jmp  new_game
*// main

*********************************************************************
*
* Main loop actions
*
main_actions:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @set_vdp_tables
       bl   @check_collisions
       bl   @user_input
       bl   @move_player
       bl   @move_other_sprites
       bl   @upload_sprites
       bl   @calculate_nt_address
       bl   @update_name_table
       bl   @display_position
       bl   @update_and_display_time_left
       bl   @display_score
       bl   @sound_player
main_return:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// main_actions

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       clr  r12
       li   r2,1
       movb @vdpsta,r1                 ; Clear interrupt if already set
       jlt  vsync_1
       inc  r2                         ; If no interrupt wait one more frame
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       socb @vdpsta,r1
       andi r1,>2000
       mov  r1,@coinc                  ; Store collision bit
       dec  r2
       jne  vsync_1
       b    *r11
*// vsync

*********************************************************************************
*
* Set VDP tables
*
set_vdp_tables:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Set pattern table according to horizontal scroll offset
       mov  @player_x,r0
       sra  r0,2                       ; Shift out sub-pixels
       andi r0,>0007                   ; Isolate pixels
       ori  r0,>0400
       bl   @vwtr
*      Flip name table
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0201
       bl   @vwtr
*      Set sprite attribute table
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0538
       bl   @vwtr
*      Flip double buffer flag
       inv  @double_buffer_flag
*      Return
       b    *r15                       ; Pop return address and return
*// set_vdp_tables

*********************************************************************************
*
* Check for sprite collisions
*
check_collisions:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @coinc,r0
       jeq  check_collisions_6
*      Collisions between player and target/tiles/enemies
       li   r1,player_sprite
       li   r2,1+n_tile_sprites+n_enemy_sprites
       li   r3,sprite_list
       bl   @check_sprite_collision
       jeq  check_collisions_3
*      Collision
       ci   r3,tile_sprite_list
       jhe  check_collisions_1
*      Collision with target
       mov  @time_left,r0
       srl  r0,4
       a    r0,@score
       bl   @play_boing
       bl   @next_level
       jmp  check_collisions_6
check_collisions_1:
       ci   r3,enemy_sprite_list
       jhe  check_collisions_2
*      Collision with tile
       mov  @sprite_count(r3),r0
       jne  check_collisions_6
       mov  @player_vx,r0
       mov  r0,@sprite_vx(r3)
       neg  r0
       sra  r0,5
       mov  r0,@sprite_ax(r3)
       mov  @player_vy,r0
       mov  r0,@sprite_vy(r3)
       neg  r0
       sra  r0,5
       mov  r0,@sprite_ay(r3)
       neg  @player_vx
       neg  @player_vy
       neg  @player_ax
       neg  @player_ay
       li   r0,32
       mov  r0,@sprite_count(r3)
       a    @d10,@score
       bl   @play_boing
       mov  *r3,r0
       ci   r0,life_pat_col
       jne  check_collisions_6
       inc  @lives
       li   r14,display_lives
       bl   @display_both_name_tables
       jmp  check_collisions_6
check_collisions_2:
       ci   r3,bullet_sprite_list
       jhe  check_collisions_6
*      Collision with enemy
       bl   @spawn_enemy_sprite
       bl   @player_hit
       jmp  check_collisions_6
*      Collisions between bullets and enemies
check_collisions_3:
       li   r6,n_bullet_sprites
       li   r7,bullet_sprite_list
check_collisions_4:
       mov  r7,r1
       li   r2,n_enemy_sprites
       li   r3,enemy_sprite_list
       bl   @check_sprite_collision
       jne  check_collisions_5
       ai   r7,sprite_size
       dec  r6
       jne  check_collisions_4
       jmp  check_collisions_6
*      Collision with enemy
check_collisions_5:
       a    @d10,@score
       bl   @play_boing
       bl   @spawn_enemy_sprite
*      Return
check_collisions_6:
       b    *r15                       ; Pop return address and return
*// check_collisions

*********************************************************************************
*
* Check sprite collision
*
* r1: Source sprite
* r2: Number of sprites to test
* r3: First sprite to test
*
* On return r0 is -1 is there is a collision
* EQ is reset, and r3 points to the collision sprite
*
check_sprite_collision:
       mov  @sprite_x(r1),r4
       mov  @sprite_y(r1),r5
check_sprite_collision_1:
       mov  *r3,r0
       jeq  check_sprite_collision_2
       mov  r4,r0
       s    @sprite_x(r3),r0
       abs  r0
       ci   r0,>0040
       jgt  check_sprite_collision_2
       mov  r5,r0
       s    @sprite_y(r3),r0
       abs  r0
       ci   r0,>0040
       jgt  check_sprite_collision_2
       seto r0
       b    *r11
check_sprite_collision_2:
       ai   r3,sprite_size
       dec  r2
       jne  check_sprite_collision_1
       clr  r0
       b    *r11
*// check_sprite_collision

*********************************************************************************
*
* User input
*
user_input:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  @player_ax
       clr  @player_ay
*      Read joystick #1 using CRU
       bl   @read_joystick
*      Up
       sla  r0,4
       jnc  user_input_1
       mov  @dminus,@player_ay
user_input_1:
*      Down
       sla  r0,1
       jnc  user_input_2
       mov  @dplus,@player_ay
user_input_2:
*      Right
       sla  r0,1
       jnc  user_input_3
       mov  @dplus,@player_ax
user_input_3:
*      Left
       sla  r0,1
       jnc  user_input_4
       mov  @dminus,@player_ax
user_input_4:
*      If any input, set direction
       mov  @joystick_input,r1
       jeq  user_input_7
       mov  @player_ay,r1
       sla  r1,6
       mov  r1,@player_dy
       mov  @player_ax,r1
       sla  r1,6
       mov  r1,@player_dx
user_input_7:
*      Fire
       sla  r0,1
       jnc  user_input_5
*      Fire pressed
       mov  @fire,r0
       jne  user_input_6               ; Skip if pressed and not released
       seto @fire                      ; Set pressed
       bl   @add_bullet_sprite
       jmp  user_input_6
user_input_5:
*      Fire not pressed
       clr  @fire                      ; Set released
user_input_6:
       b    *r15                       ; Pop return address and return
dplus:
       data >0020
dminus:
       data ->0020
*// user_input

*********************************************************************************
*
* Move player
*
move_player:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r2,2                       ; Two coordinates (x and y)
       li   r3,player_sprite
*      Move in x then y
move_player_0:
       mov  @sprite_vx(r3),r0          ; Velocity
       mov  @sprite_ax(r3),r1          : Acceleration
       jeq  move_player_1
*      Accelerate
       a    r1,r0
       jmp  move_player_3
*      Decelerate
move_player_1:
       mov  r0,r1                      ; Velocity
       jlt  move_player_2
       ci   r1,>00c0
       jgt  move_player_2
       clr  r0                         ; Stop
       jmp  move_player_3
move_player_2:
       sra  r1,6                       ; Divide velocity by 64
       s    r1,r0                      ; Subtract from velocity
move_player_3:
       mov  r0,@sprite_vx(r3)          ; Save velocity
       sra  r0,6                       ; Shift to LSB
       a    r0,@sprite_x(r3)           ; Add to position
*      Next coord
       inct r3
       dec  r2
       jne  move_player_0
*      Blaking when hit
       mov  @player_count,r0
       jeq  move_player_5
       dec  r0
       jgt  move_player_4
       li   r0,>01e2
       bl   @vwtr
       li   r0,>0700
       bl   @vwtr
move_player_4:
       mov  r0,@player_count
*      Return
move_player_5:
       b    *r15
*// move_player

*********************************************************************************
*
* Move other sprites
*
move_other_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r2,n_sprites
       li   r3,tile_sprite_list
move_other_sprites_1:
       mov  *r3,r0
       jeq  move_other_sprites_5
*      Check for out of bounds
       mov  @player_x,r0
       s  @sprite_x(r3),r0
       abs  r0
       ci   r0,>0400
       jgt  move_other_sprite_2
       mov  @player_y,r1
       s  @sprite_y(r3),r1
       abs  r1
       ci   r1,>0400
       jgt  move_other_sprite_2
*      Move
       bl   @move_sprite
*      Check sprite counter for tiles
       ci   r3,enemy_sprite_list
       jhe  move_other_sprites_5
       mov  @sprite_count(r3),r0
       jeq  move_other_sprites_5
       dec  @sprite_count(r3)
       jgt  move_other_sprites_5
       bl   @spawn_tile_sprite
       jmp  move_other_sprites_5
*      Out of bounds
move_other_sprite_2:
       ci   r3,enemy_sprite_list
       jhe  move_other_sprites_3
*      Tile sprite out of bounds
       bl   @spawn_tile_sprite
       jmp  move_other_sprites_5
move_other_sprites_3:
       ci   r3,bullet_sprite_list
       jhe  move_other_sprites_4
*      Enemy sprite out of bounds
       bl   @spawn_enemy_sprite
       jmp  move_other_sprites_5
move_other_sprites_4:
*      Bullet out of bounds
       clr  *r3
move_other_sprites_5:
       ai   r3,sprite_size
       dec  r2
       jne  move_other_sprites_1
*      Return
       b    *r15                       ; Pop return address and return
*// move_other_sprites

*********************************************************************************
*
* Upload visible sprites to VDP. Also handles animation.
*
upload_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
*      VDP address
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0038
       sla  r0,7
*      Player
       mov  @player_pattern,r1
       mov  @joystick_input,r2
       jeq  upload_sprites_1
       movb @dir_sprite_table(r2),r2
       cb   r2,r1
       jeq  upload_sprites_1
       jlt  upload_sprites_6
       ab   @two,r1
       jmp  upload_sprites_7
upload_sprites_6:
       sb   @two,r1
upload_sprites_7:
;       andi r1,>9f0f
       mov  r1,@player_pattern
upload_sprites_1:
       ai   r0,16+2
       bl   @vsbw
       movb @r1lb,*r13
*      Tile and enemy sprites
       mov  @player_y,r6
       andi r6,>fffc                   ; Needed for steady sprites
       ai   r6,-(center_y*4)
       mov  @player_x,r7
       andi r7,>fffc                   ; Needed for steady sprites
       ai   r7,-(center_x*4)
*      Enemy pattern
       mov  @frame_no,r8
       andi r8,>001c
       swpb r8
*      Loop
       li   r2,1+n_sprites
       li   r3,sprite_list
upload_sprites_2:
       mov  *r3,r1
       jeq  upload_sprites_5
       cb   r1,@ba0
       jne  upload_sprites_3
       a    r8,r1                      ; Animate enemy
upload_sprites_3:
       mov   @sprite_y(r3),r4
       s    r6,r4
       sra  r4,2
       mov   @sprite_x(r3),r5
       s    r7,r5
       sra  r5,2
       ci   r4,191
       jgt  upload_sprites_5
       ci   r4,-15
       jlt  upload_sprites_5
       ci   r5,255
       jgt  upload_sprites_5
       ci   r5,-15
       jlt  upload_sprites_5
       ci   r5,0
       jgt  upload_sprites_4
       ai   r5,32
       ori  r1,>0080                   ; Set early clock
upload_sprites_4:
       dec  r4
       movb @r4lb,*r13
       movb @r5lb,*r13
       movb r1,*r13
       movb @r1lb,*r13
upload_sprites_5:
       ai   r3,sprite_size
       dec  r2
       jne  upload_sprites_2
*      End marker
       li   r1,>d000
       movb r1,*r13
*      Return
       b    *r15                       ; Pop return address and return
dir_sprite_table:
       byte >80                        ; 0 0000 None
       byte >90                        ; 1 0001 Left
       byte >80                        ; 2 0010 Right
       byte >80                        ; 3 0011 Left + right (N/A) = right
       byte >88                        ; 4 0100 Up
       byte >9c                        ; 5 0101 Up + left
       byte >94                        ; 6 0110 Up + right
       byte >94                        ; 7 0111 Up + left + right (N/A) = up + right
       byte >98                        ; 8 1000 Down
       byte >84                        ; 9 1001 Down + left
       byte >8c                        ; A 1010 Down + right
       byte >8c                        ; B 1011 Down + left + right (N/A) = down + right
       byte >88                        ; C 1100 Up + down (N/A) = up
       byte >9c                        ; D 1101 Up + down + left (N/A) = up + left
       byte >94                        ; E 1110 Up + down + right (N/A) = up + right
       byte >94                        ; F 1111 Up + down + left + right (N/A) = up + right
*// update_sprites

*********************************************************************************
*
* Calculate address of current name table double buffer
*
calculate_nt_address:
       mov  @double_buffer_flag,r0
       andi r0,>0002
       ori  r0,>0001
       sla  r0,10
       mov  r0,@double_buffer_address
       b    *r11
*// calculate_nt_address

*********************************************************************************
*
* Update name table
*
update_name_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       bl   @vwad
       li   r0,8
*      Tile offsets
       mov  @player_x,r4
       sra  r4,5                       ; Shift out pixels and sub-pixels
       andi r4,7                       ; Column offset
       mov  @player_y,r5
       mov  r5,r6
       sra r5,5                        ; Row offset
       andi r6,>001c                   ; Pixel row offset * 4
*      Row loop
       clr  r3
update_name_table_1:
       mov  r3,r1                      ; Row
       a    r5,r1                      ; Add row offset
       andi r1,7                       ; Mod 8
       sla  r1,1                       ; To word offset
       mov  @map_row_index(r1),r1      ; Map row number
       a    r6,r1                      ; Add pixel row offset
       sla  r1,4                       ; Multiply by 16
       ai   r1,map_rows
       a    r4,r1                      ; Add column offset
*      Column loop
       li   r2,win_width/8
       bl   @copy_loop
*      Next row
       inc  r3
       ci   r3,win_height
       jlt  update_name_table_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*      Copy loop
copy_loop_1:
       movb *r1+,*r13                  ; Write to VDP
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       movb *r1+,*r13
       s    r0,r1
       dec  r2
       jne  copy_loop_1
       b    *r11
copy_loop_2
*// update_name_table

*********************************************************************************
*
* Update and display time left
*
update_and_display_time_left:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @time_left,r0
       jeq  update_and_display_time_left_1
       ai   r0,-8
       mov  r0,@time_left
       andi r0,>00ff
       jne  update_and_display_time_left_2
       li   r14,display_time_left
       bl   @display_both_name_tables
       jmp  update_and_display_time_left_2
*      Time's up
update_and_display_time_left_1:
       mov  @player_count,r0
       jgt  update_and_display_time_left_2
       bl   @player_hit
*      Return
update_and_display_time_left_2:
       b    *r15                       ; Pop return address and return
*// update_and_display_time_left

*********************************************************************************
*
* Display position
*
display_position:
       mov  r11,*r10+                  ; Push return address onto the stack
*      x
       mov  @double_buffer_address,r0
       ai   r0,22*32+2
       bl   @vwad
       mov  @player_x,r1
       bl   @display_byte
*      y
       mov  @double_buffer_address,r0
       ai   r0,22*32+9
       bl   @vwad
       mov  @player_y,r1
       bl   @display_byte
*      Return
       b    *r15                       ; Pop return address and return
*// display_position

*********************************************************************************
*
* Display to both name tables
*
* r14: Display routine to execute
*
display_both_name_tables:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r0,nametb
       mov  r0,@double_buffer_address
       bl   *r14
       li   r0,namet1
       mov  r0,@double_buffer_address
       bl   *r14
*      Return
       b    *r15                       ; Pop return address and return
*// display_both_name_tables

*********************************************************************************
*
* Display time left
*
display_time_left:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       ai   r0,23*32+5
       bl   @vwad
       mov  @time_left,r1
       bl   @display_unsigned_byte
*      Return
       b    *r15                       ; Pop return address and return
*// display_time_left

*********************************************************************************
*
* Display target position
*
display_target_position:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Target x
       mov  @double_buffer_address,r0
       ai   r0,22*32+21
       bl   @vwad
       mov  @sprite_list+sprite_x,r1
       bl   @display_byte
*      Target y
       mov  @double_buffer_address,r0
       ai   r0,22*32+28
       bl   @vwad
       mov  @sprite_list+sprite_y,r1
       bl   @display_byte
*      Return
       b    *r15                       ; Pop return address and return
*// display_target_position

*********************************************************************************
*
* Display score
*
display_score:
       mov  r11,*r10+                  ; Push return address onto the stack
       c    @score,@disp_score
       jeq  display_score_1
       li   r14,display_score_2
       bl   @display_both_name_tables
       mov  @score,@disp_score
*      Return
display_score_1:
       b    *r15                       ; Pop return address and return
display_score_2:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       ai   r0,23*32+13
       bl   @vwad
       mov  @score,r1
       li   r2,5
       bl   @display_decimal
*      Return
       b    *r15                       ; Pop return address and return
*// display_score

*********************************************************************************
*
* Display lives
*
display_lives:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       ai   r0,23*32+23
       bl   @vwad
       mov  @lives,r1
       li   r2,2
       bl   @display_decimal
*      Return
       b    *r15                       ; Pop return address and return
*// display_lives

*********************************************************************************
*
* Display level
*
display_level:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @double_buffer_address,r0
       ai   r0,23*32+30
       bl   @vwad
       mov  @level,r1
       li   r2,2
       bl   @display_decimal
*      Return
       b    *r15                       ; Pop return address and return
*// display_level

*********************************************************************************
*
* Move sprite
*
move_sprite:
       a    @sprite_ax(r3),@sprite_vx(r3)
       a    @sprite_ay(r3),@sprite_vy(r3)
       mov  @sprite_vx(r3),r0
       sra  r0,6
       a    r0,@sprite_x(r3)
       mov  @sprite_vy(r3),r0
       sra  r0,6
       a    r0,@sprite_y(r3)
       b    *r11
*// move_sprite

*********************************************************************************
*
* Spawn enemy sprite
*
* r3: address of enemy sprite
*
spawn_enemy_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @rand
       andi r0,>000f
       ori  r0,enemy_pat_col
       mov  r0,*r3
       bl   @rand
       sra  r0,7
       mov  r0,@sprite_vx(r3)
       bl   @rand
       sra  r0,7
       mov  r0,@sprite_vy(r3)
       bl   @rand
       sra  r0,12
       mov  r0,@sprite_ax(r3)
       bl   @rand
       sra  r0,12
       mov  r0,@sprite_ay(r3)
       jmp  spawn_sprite_1
*// spawn_enemy_sprite

*********************************************************************************
*
* Spawn tile sprite
*
* r3: address of tile sprite
*
spawn_tile_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @rand
       ci   r0,>fc00
       jhe  spawn_tile_sprite_1
       li   r0,ball_pat_col
       jmp  spawn_tile_sprite_2
spawn_tile_sprite_1:
       li   r0,life_pat_col
spawn_tile_sprite_2:
       mov  r0,*r3
       clr  @sprite_vx(r3)
       clr  @sprite_vy(r3)
       clr  @sprite_ax(r3)
       clr  @sprite_ay(r3)
       jmp  spawn_sprite_1
*// spawn_tile_sprite

*********************************************************************************
*
* Spawn sprite
*
* r3: address of tile sprite
*
spawn_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
spawn_sprite_1:
*      x
       bl   @rand
       andi r0,>000f
       ai   r0,-8                      ; -8 - 7 meta tiles
       mov  r0,r4
*      y
       bl   @rand
       andi r0,>000f
       ai   r0,-8                      ; -8 - 7 meta tiles
       mov  r0,r5
*      Square of distance
       bl   @dist_square
       ci   r9,9                       ; dist^2 < 9 <=> dist < 3
       jlt  spawn_sprite_1             ; Try again if too close
*      Finalize
       sla  r4,8
       a    @player_x,r4
       andi r4,>ff00                   ; Round to meta tiles
       ori  r4,>0060                   ; Center on meta tile
       sla  r5,8
       a    @player_y,r5
       andi r5,>ff00                   ; Round to meta tiles
       ori  r5,>0060                   ; Center on meta tile
*      Check for other sprite at same position
       li   r1,sprite_list
       li   r0,1+n_tile_sprites+n_bullet_sprites
spawn_sprite_2:
       c    r4,@sprite_x(r1)
       jne  spawn_sprite_3
       c    r5,@sprite_y(r1)
       jne  spawn_sprite_3
       jmp  spawn_sprite_1             ; Same position - try again
spawn_sprite_3:
       ai   r1,sprite_size
       dec  r0
       jne  spawn_sprite_2
*      Update position
       mov  r4,@sprite_x(r3)
       mov  r5,@sprite_y(r3)
       clr  @sprite_count(r3)
*      Return
       b    *r15                       ; Pop return address and return
*// spawn_sprite

*********************************************************************************
*
* Add bullet sprite
*
add_bullet_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r2,n_bullet_sprites
       li   r3,bullet_sprite_list
add_bullet_sprite_1:
       mov  *r3,r0
       jeq  add_bullet_sprite_2
       ai   r3,sprite_size
       dec  r2
       jne  add_bullet_sprite_1
       jmp  add_bullet_sprite_3
add_bullet_sprite_2:
       li   r0,bullet_pat_col
       mov  r0,*r3+
       li   r1,player_x
       mov  *r1+,*r3+                  ; x
       mov  *r1+,*r3+                  ; y
       mov  *r1+,*r3                   ; vx
       a    @player_dx,*r3+            ; Add dx
       mov  *r1+,*r3                   ; vy
       a    @player_dy,*r3+            ; Add dy
       clr  *r3+                       ; ax
       clr  *r3+                       ; ay
       clr  *r3+                       ; count
       ai   r3,-sprite_size            ; To start of struct
       bl   @move_sprite               ; Move away from player
       bl   @play_shot
*      Return
add_bullet_sprite_3:
       b    *r15
*// add_bullet_sprite

*********************************************************************************
*
* Player hit
*
player_hit:
       mov  r11,*r10+                  ; Push return address onto the stack
       dec  @lives
       li   r14,display_lives
       bl   @display_both_name_tables
       mov  @lives,r0
       jeq  player_hit_1
       li   r0,>01a2
       bl   @vwtr
       li   r0,>070f
       bl   @vwtr
       mov  @d10,@player_count
       bl   @play_shot
*      Return
player_hit_1:
       b    *r15                       ; Pop return address and return
*// player_hit

*********************************************************************************
*
* Advance to next level
*
next_level:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Init sprites
       li   r8,n_enemy_sprites
       li   r3,enemy_sprite_list
next_level_1:
       c    r8,@level
       jgt  next_level_2
       bl   @spawn_enemy_sprite
       jmp  next_level_3
next_level_2:
       clr  *r3
next_level_3:
       ai   r3,sprite_size
       dec  r8
       jne  next_level_1
       li   r8,n_bullet_sprites
next_level_4:
       clr  *r3
       ai   r3,sprite_size
       dec  r8
       jne  next_level_4
*      Update target position
next_level_5:
       bl   @rand
       sra  r0,8
       mov  r0,r4
       bl   @rand
       sra  r0,8
       mov  r0,r5
       bl   @dist_square
       li   r1,8
       mov  @level,r0
       inc  r0
       sla  r1,0
       c    r9,r1
       jgt next_level_5
*      Target x
       sla  r4,8
       a    @player_x,r4
       andi r4,>ff00
       ori  r4,>0060
       mov  r4,@sprite_list+sprite_x
*      Target y
       sla  r5,8
       a    @player_y,r5
       andi r5,>ff00
       ori  r5,>0060
       mov  r5,@sprite_list+sprite_y
*      Target pattern and color
       li   r0,target_pat_col
       mov  r0,@sprite_list+sprite_pattern
*      Display position
       li   r14,display_target_position
       bl   @display_both_name_tables
*      Reset time
       li   r0,>6400
       mov  r0,@time_left
*      Colors
       li   r0,colrtb
       mov  @level,r1
       andi r1,7
       movb @level_colors(r1),r1
       li   r2,16
       bl   @vsmw
*      Next level
       inc  @level
*      Display level
       li   r14,display_level
       bl   @display_both_name_tables
*      Return
       b    *r15                       ; Pop return address and return
level_colors:
       byte >f1,>1d,>f4,>1a,>f6,>15,>fc,>1e
*// next_level

*********************************************************************************
*
* Initialize game
*
init_game:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @mute_sound
       li   r0,pad_init_start
       clr  *r0
       li   r1,pad_init_start+2
       li   r2,pad_init_end-pad_init_start
       bl   @copy_memory
       li   r0,init_player_data
       mov  *r0+,@player_pattern
       mov  *r0+,@player_x
       mov  *r0+,@player_y
       mov  *r0,@player_dx
       seto @disp_score
       li   r0,3
       mov  r0,@lives
       li   r14,display_lives
       bl   @display_both_name_tables
*      Init sprites
       li   r8,n_tile_sprites
       li   r3,tile_sprite_list
init_game_1:
       bl   @spawn_tile_sprite
       ai   r3,sprite_size
       dec  r8
       jne  init_game_1
*      Next level
       bl   @next_level
*      Init display
       bl   @main_actions
       bl   @main_actions
*      Disable blanking
       li   r0,>01e2
       bl   @vwtr
*      Return
       b    *r15                       ; Pop return address and return
init_player_data:
       data player_pat_col,start_x,start_y,>0800
*// init_game

*********************************************************************
*
* Square of distance
* Calculates r9=abs(r4)^2+abs(r5)
*
* Modifies r0,r1
*
dist_square:
       mov  r4,r0
       abs  r0
       mpy r0,r0
       mov  r1,r9
       mov  r5,r0
       abs  r0
       mpy  r0,r0
       a    r1,r9
       b    *r11
*// dist_square

*********************************************************************
*
* Copy memory
*
* r0: Source address
* r1: Destination address
* r2: Length
*
copy_memory:
       mov  *r0+,*r1+
       dect r2
       jne  copy_memory
       b    *r11
*// copy_memory

*********************************************************************
*
* Display signed byte
*
* r1: Byte to display in MSB
*
display_byte:
       sra  r1,8
       jgt  display_byte_1
       jlt  display_byte_2
       movb @space,*r13
       jmp  display_byte_3
display_byte_1:
       movb @plus,*r13
       jmp  display_byte_3
display_byte_2:
       movb @minus,*r13
       neg  r1
display_byte_3:
       li   r2,3
       jmp  display_decimal
plus:
       byte chr_plus
minus:
       byte chr_minus
space:
       byte chr_space

*********************************************************************
*
* Display unsigned byte
*
* r1: Byte to display in MSB
*
display_unsigned_byte:
       sra  r1,8
       li   r2,3
       jmp  display_decimal
*// display_unsigned_byte

*********************************************************************
*
* Display decimal number
* VDP address must already be set up.
*
* r1: number to display
* r2: number of digits
*
display_decimal:
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       ai   r0,chr_zero
       movb @r0lb,*r13
       dec  r2
       jne  display_decimal_1
       ai   r1,chr_zero
       movb @r1lb,*r13
       b    *r11
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// display_decimal

*********************************************************************************
*
* Display text to both name table buffers (slow)
*
* r0: VDP offset
* r1: Points to zero terminated ascii text
*
display_text:
       mov  r11,*r10+                  ; Push return address onto the stack
       ai   r0,nametb
       bl   @vwad
       li   r2,buffer
display_text_0:
       movb *r1+,r4
       jeq  display_text_4
       li   r5,charset
       clr  r6
display_text_1:
       cb   r4,*r5+
       jeq  display_text_2
       inc  r6
       ci   r6,32
       jlt  display_text_1
       li   r6,chr_question
       jmp  display_text_3
display_text_2:
       ai   r6,>00e0
display_text_3:
       swpb r6
       movb r6,*r13
       movb r6,*r2+
       jmp  display_text_0
*      2nd name table buffer
display_text_4:
       ai   r0,namet1-nametb
       li   r1,buffer
       ai   r2,-buffer
       bl   @vmbw
*      Return
       b    *r15                       ; Pop return address and return
*// display_text


*********************************************************************************
*
* Wait for fire
*
wait_fire:
       mov  r11,*r10+                  ; Push return address onto the stack
wait_fire_1:
       bl   @read_joystick
       tb   0
       jeq  wait_fire_1
wait_fire_2:
       tb   0
       jne  wait_fire_2
*      Return
       b    *r15                       ; Pop return address and return
*// wait_fire

*********************************************************************
*
* Read joystick #1 using CRU
*
* Result: R0 MSB contains 0, 0, 0, Up, Down, Right, Left, Fire
*
read_joystick:
       li   r12,>0024                  ; CRU address of the column decoder
       li   r0,>0600                   ; Column 6, i.e joystick #1
       ldcr r0,3                       ; Select it
       li   r12,>0006                  ; Base CRU address for joystick 1
       stcr r1,5                       ; Read 5 bits into MSB
       inv  r1                         ; Make 1=pressed
       andi r1,>1f00
       mov  r1,r0                      ; Copy
       srl  r1,9                       ; Move to LSB
       mov  r1,@joystick_input         ; Save in variable
       b    *r11
*// read_joystick

*********************************************************************
*
* Random number generator
*
* The random number is returned in r0.
* Modifies r1
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       mov  r1,r0
       ai   r0,31873                   ; Add a prime number
       src  r0,7                       ; Shift to break odd/even pattern
       mov  r0,@rand_no
       b    *r11
*// rand

*********************************************************************
*
* VDP Write To Register
*
* r0 MSB: VDP register to write to
* r0 LSB: Value to write
*
vwtr:
       movb @r0lb,@vdpwa               ; Send low byte (value) to write to VDP register
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* r0: Write address in VDP RAM
*
* r0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Write
*
* r0: Write address in VDP RAM
* r1: MSB of R1 sent to VDP RAM
*
* r0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,*r13                    ; Write byte to VDP RAM
       b    *r11
*// vsbw

*********************************************************************
*
* VDP Single Byte Multiple Write
*
* r0: Write address in VDP RAM
* r1: MSB of R1 sent to VDP RAM
* r2: Number of bytes to send
*
* r0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsmw:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vsmw_1:
       movb r1,*r13                    ; Write byte to VDP RAM
       dec  r2
       jne  vsmw_1
       b    *r11
*// vsbw

*********************************************************************
*
* VDP Multiple Byte Write
*
* r0: Destination address
* r1: Source address
* r2: Number of bytes to copy
*
vmbw:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbw_1:
       movb *r1+,*r13                  ; Write byte to VDP RAM
       dec  r2
       jne  vmbw_1
       b    *r11
*// vdpcp

***************************************************************************
*
* VDP Multiple Byte Read
*
* r0: Starting read address in VDP RAM
* r1: Starting write address in CPU RAM
* r2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       movb @r0lb,@vdpwa               ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdprd
vmbr_1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr_1                     ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Code that should reside after initilization
*
       copy "sound.a99"

*********************************************************************
*
* Data that should reside after initilization
*
       copy "charset.a99"
       copy "map.a99"

text_fire_to_start:
       text "FIRE TO START"
       byte 0
text_game_over:
       text "GAME OVER"
       byte 0

ba0:   byte >a0
two:   byte >02

*********************************************************************
*
* Code that is only needed once to initialize the game
*
one_time_code:
       copy "init.a99"

*********************************************************************
*
* Data only needed for initialization
*
text_line_1:
       text "X= 000 Y= 000 GOTO X= 000 Y= 000"
       byte 0
text_line_2:
       text "TIME:100 SCR:00000 LVS:03 LVL:01"
       byte 0

       copy "graphics.a99"
       copy "sprite-patterns.a99"

sprite_list:
       equ  one_time_code
tile_sprite_list:
       equ  sprite_list+sprite_size
enemy_sprite_list:
       equ  sprite_size*n_tile_sprites+tile_sprite_list
bullet_sprite_list:
       equ  sprite_size*n_enemy_sprites+enemy_sprite_list
sprite_list_end:
       equ  sprite_size*n_bullet_sprites+bullet_sprite_list
map_rows:
       equ  sprite_list_end

*********************************************************************
